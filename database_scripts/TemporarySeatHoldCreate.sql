CREATE TABLE dbo.TemporarySeatHolds (
    HoldID INT PRIMARY KEY IDENTITY(1,1),
    TripID INT NOT NULL,
    SeatID INT NOT NULL,
	CoachID INT NOT NULL,
    legOriginStationId INT NOT NULL, -- Crucial addition
    legDestinationStationId INT NOT NULL,   -- Crucial addition
    SessionID NVARCHAR(100) NOT NULL, -- Or a unique Hold Token generated by the server
    UserID INT NULL,                  -- If user is logged in
    ExpiresAt DATETIME2 NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETDATE(),

    CONSTRAINT FK_TemporarySeatHolds_Trip FOREIGN KEY (TripID) REFERENCES dbo.Trips(TripID) ON DELETE CASCADE,
    CONSTRAINT FK_TemporarySeatHolds_Seat FOREIGN KEY (SeatID) REFERENCES dbo.Seats(SeatID) ON DELETE CASCADE,
    CONSTRAINT FK_TemporarySeatHolds_StartStation FOREIGN KEY (legOriginStationId) REFERENCES dbo.Stations(StationID),
    CONSTRAINT FK_TemporarySeatHolds_EndStation FOREIGN KEY (legDestinationStationId) REFERENCES dbo.Stations(StationID),
	CONSTRAINT FK_TemporarySeatHolds_Coachh FOREIGN KEY (CoachID) REFERENCES dbo.Coaches(CoachID),
    CONSTRAINT FK_TemporarySeatHolds_User FOREIGN KEY (UserID) REFERENCES dbo.Users(UserID) ON DELETE SET NULL
    -- No simple UNIQUE constraint on (TripID, SeatID) anymore.
    -- Uniqueness/conflict is checked by the "hold seat" logic based on overlapping segments.
);

-- Index for efficient checking of active holds on a seat for a trip
CREATE INDEX IX_TemporarySeatHolds_TripSeat_Active ON dbo.TemporarySeatHolds (TripID, SeatID, ExpiresAt);
-- Index for cleanup job
CREATE INDEX IX_TemporarySeatHolds_ExpiresAt ON dbo.TemporarySeatHolds (ExpiresAt);